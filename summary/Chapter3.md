# 애그리거트

### 1. 애그리거트
* 복잡한 도메인을 이해하고 관리하기 쉬운 단어로 만들려면, 상위 수준에서 모델을 조망할 수 있는 방법이 필요하다.
* 그 방법을 애그리거트라 한다.
* 수 많은 객체를 애그리거트로 묶어 바라보면, 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.
* 관련된 모델을 하나로 모았기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖는다.
* 대부분의 경우엔 애그리거트에 속한 구성요소는 함께 생성하고 함께 제거한다.
* 함께 변경되는 빈도가 높은 객체는 한 애그리거트에 속할 가능성이 크다.
* ex) Order
  * Order, OrderLine, Orderer, ShippingInfo 등은 하나의 주문 애그리거트로 볼 수 있다.
* 애그리거트는 경계를 갖고, 한 쪽에 속한 객체는 다른 쪽에 속하지 않도록 한다.
* ex) 주문 애그리거트는 배송지를 변경하거나 상품 갯수를 변경하지만, 회원의 비밀번호를 변경하진 않는다.
* _A가 B를 갖는다_ 로 설계할 수 있는 요구사항이 있다면, 한 애그리거트로 생각하기 쉽다.
* 반드시 옳지만은 않은데, 좋은 예가 상품과 리뷰이다.
* 상품 상세에 들어가면 리뷰 내용을 보여준다는 요구사항이 있다고 하자.
  * Product와 Review는 함께 생성되지 않고, 함께 변경되지도 않는다.
  * Product의 변경 주체는 상품 담당자 / Review의 변경 주체는 고객이다.
* 애그리거트를 처음 시작하면 큰 애그리거트로 보이지만, 도메인에 대한 경험이 생기고 규칙이 생길수록 실제 애그리거트는 줄어든다.
* 다수의 애그리거트는 한 개의 엔티티 객체만 갖는 경우가 많다.

### 2. 애그리거트 루트
* 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 책임지고 관리할 주체
* 애그리거트에 속한 객체는 애그리거트 루트에 직접/간접적으로 속한다.
* 주문 애그리거트의 애그리거트 루트는 Order이고, OrderLine, ShippingInfo 등은 주문 애그리거트에 직/간접적으로 속한다.
* 도메인 규칙과 일관성
  * 애그리거트 루트의 핵심은 애그리거트의 일관성이 깨지지 않는 것이다.
  * 애그리거트 루트는 도메인의 기능 구현을 담당한다.
  * 주문의 경우 배송지 변경, 상품 변경 등의 기능을 애그리거트 루트인 Order가 제공한다.
    * 이 때 일관성을 지키기 위한 규칙 또한 애그리거트 루트가 담당한다.
    * ex) 배송이 시작되기 전까지만 배송지 정보를 변경할 수 있다. 등
  * 애그리거트 외부에서 애그리거트에 속한 객체를 변경해선 안된다.
    * 애그리거트 루트가 일괄적으로 담당하기 때문
  * 애그리거트 루트를 통해서만 도메인 로직을 구현하고, 규칙을 적용한다.
    * public setter 금지
    * 밸류타입은 불변으로 구현 
    * 등
* 애그리거트 루트의 기능 구현
  * ex) Order - List<OrderLine>
    * 이 경우, Order 애그리거트에서 OrderLines 참조를 가져와 데이터를 바꾼다면, 상품 목록은 바뀌지만 총합은 계산하지 않는다.
    * 애초에 애그리거트 외부에서 OrderLines를 바꿀 수 없도록 protected 등으로 제한한다.
* 트랜잭션 범위
  * 트랜잭션의 범위는 작을 수록 좋다.
  * 동리한 트랜잭션에서는 한 개의 애그리거트만 수정한다.
  * 부득이하게 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면, 응용 서비스에서 두 애그리거트를 수정하도록 구현한다.

### 3. 리포지터리와 애그리거트
* 애그리거트는 개념상 완전한 한 개의 도메인 모델이므로 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.
* Order, OrderLine을 물리적으로 각각의 DB 테이블에 저장한다 해도, 각각을 위한 리포지터리를 만들진 않는다.
* 구현하는 기술에 따라 (NoSQL, RDBMS 등) 구현체를 만들지만 각 애그리거트를 다른 기술을 통해 영속화 한다면 트랜잭션 처리를 잘 해야한다.

### 4. ID를 이용한 애그리거트 참조
* 애그리거트 루트도 다른 애그리거트 루트를 참조한다.
* ORM 등을 이용할 때, 편한 객체참조로 다른 애그리거트의 상태를 바꾸면 안된다.
  * 주문 애그리거트를 조회하여 주문자 애그리거트를 가져와 회원 정보를 변경할 수 있는 유혹에 빠지기 쉽다
* 응용서비스 영역에서 하나의 애그리거트 루트를 조회하여 원하는 애그리거트를 얻어낸 뒤, 그것의 ID를 가져와 다시 조회하는 식으로 사용한다.